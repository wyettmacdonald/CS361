/*
 * File: bantam.parser.Parser.java
 * CS361 Project 11
 * Names: Martin Deutsch and Wyett MacDonald
 * Date: 2/13/2019
 * This file contains the Parser, which parses the source file
 * and generates the AST
 */

/*
 * File: bantam.parser.Parser.java
 * CS361 Project 10
 * Names: Douglas Abrams, Martin Deutsch, Robert Durst, Matt Jones
 * Date: 12/07/2018
 * This file contains the Parser, which parses the source file
 * and generates the AST
 */

/*
 * Authors: Haoyu Song and Dale Skrien
 * Date: Spring and Summer, 2018
 *
 * In the grammar below, the variables are enclosed in angle brackets.
 * The notation "::=" is used instead of "-->" to separate a variable from its rules.
 * The special character "|" is used to separate the rules for each variable.
 * All other symbols in the rules are terminals.
 * EMPTY indicates a rule with an empty right hand side.
 * All other terminal symbols that are in all caps correspond to keywords.
 */
package proj11DeutschMacDonald.bantam.parser;

import static proj11DeutschMacDonald.bantam.lexer.Token.Kind.*;

import proj11DeutschMacDonald.bantam.ast.*;
import proj11DeutschMacDonald.bantam.lexer.*;
import proj11DeutschMacDonald.bantam.util.*;
import proj11DeutschMacDonald.bantam.util.Error;

/**
 * This class constructs an AST from a legal Bantam Java program.  If the
 * program is illegal, then one or more error messages are displayed.
 *
 * @author Haoyu Song
 * @author Dale Skrien
 */
public class Parser {
    // instance variables
    private Scanner scanner;
    private Token currentToken; // the lookahead token
    private ErrorHandler errorHandler;
    private String fileName;

    // constructor
    public Parser(ErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
    }


    /**
     * parse the given file and return the root node of the AST
     *
     * @param filename The name of the Bantam Java file to be parsed
     * @return The Program node forming the root of the AST generated by the parser
     */
    public Program parse(String filename) throws CompilationException {
        this.fileName = filename;
        this.scanner = new Scanner(filename, this.errorHandler);
        advance();
        return parseProgram();
    }


    /*
     * <Program> ::= <Class> | <Class> <Program>
     */
    private Program parseProgram() {
        int position = currentToken.position;
        ClassList classList = new ClassList(position);

        while (currentToken.kind != EOF) {
            Class_ aClass = parseClass();
            classList.addElement(aClass);
        }
        return new Program(position, classList);
    }


    /*
     * <Class> ::= CLASS <Identifier> <ExtendsClause> { <MemberList> }
     * <ExtendsClause> ::= EXTENDS <Identifier> | EMPTY
     * <MemberList> ::= EMPTY | <Member> <MemberList>
     */
    private Class_ parseClass() {
        int position = currentToken.position;
        checkTokenAndAdvance(position, CLASS, "class");
        String name = parseIdentifier();

        // get parent if exists
        String parent = null;
        if (currentToken.kind == EXTENDS) {
            advance();
            parent = parseIdentifier();
        }

        // get member list
        MemberList memberList = new MemberList(position);
        checkTokenAndAdvance(position, LCURLY, "{");
        while (currentToken.kind != RCURLY) {
            Member aMember = parseMember();
            memberList.addElement(aMember);
        }

        // don't use advance() here because we can hit EOF
        currentToken = scanner.scan();
        while (currentToken.kind == COMMENT) {
            currentToken = scanner.scan();
        }
        return new Class_(position, fileName, name, parent, memberList);
    }


    /* Fields and Methods
     * <Member> ::= <Field> | <Method>
     * <Method> ::= <Type> <Identifier> ( <Parameters> ) <Block>
     * <Field> ::= <Type> <Identifier> <InitialValue> ;
     * <InitialValue> ::= EMPTY | = <Expression>
     */
    private Member parseMember() {
        int position = currentToken.position;

        String type = parseType();
        String name = parseIdentifier();

        // handle method
        if (currentToken.kind == LPAREN) {
            advance();
            FormalList formalList = parseParameters();
            checkTokenAndAdvance(position, RPAREN, ")");
            StmtList stmtList = ((BlockStmt) parseBlock()).getStmtList();
            return new Method(position, type, name, formalList, stmtList);
        }

        // handle field
        Expr init = null;
        if (currentToken.kind == ASSIGN) {
            advance();
            init = parseExpression();
        }
        checkTokenAndAdvance(position, SEMICOLON, ";");

        return new Field(position, type, name, init);
    }

    //-----------------------------------

    /* Statements
     *  <Stmt> ::= <WhileStmt> | <ReturnStmt> | <BreakStmt> | <DeclStmt>
     *              | <ExpressionStmt> | <ForStmt> | <BlockStmt> | <IfStmt>
     */
    private Stmt parseStatement() {
        Stmt stmt;

        switch (currentToken.kind) {
            case IF:
                stmt = parseIf();
                break;
            case LCURLY:
                stmt = parseBlock();
                break;
            case VAR:
                stmt = parseDeclStmt();
                break;
            case RETURN:
                stmt = parseReturn();
                break;
            case FOR:
                stmt = parseFor();
                break;
            case WHILE:
                stmt = parseWhile();
                break;
            case BREAK:
                stmt = parseBreak();
                break;
            default:
                stmt = parseExpressionStmt();
        }
        return stmt;
    }


    /*
     * <WhileStmt> ::= WHILE ( <Expression> ) <Stmt>
     */
    private Stmt parseWhile() {
        int position = currentToken.position;
        advance();

        checkTokenAndAdvance(position, LPAREN, "(");
        Expr expr = parseExpression();
        checkTokenAndAdvance(position, RPAREN, ")");
        Stmt stmt = parseStatement();
        return new WhileStmt(position, expr, stmt);
    }


    /*
     * <ReturnStmt> ::= RETURN <Expression> ; | RETURN ;
     */
    private Stmt parseReturn() {
        int position = currentToken.position;
        advance();

        Expr expr = null;
        if (currentToken.kind != SEMICOLON) {
            expr = parseExpression();
        }
        checkTokenAndAdvance(position, SEMICOLON, ";");

        return new ReturnStmt(position, expr);
    }


    /*
     * <BreakStmt> ::= BREAK ;
     */
    private Stmt parseBreak() {
        int position = currentToken.position;
        advance();
        checkTokenAndAdvance(position, SEMICOLON, ";");
        return new BreakStmt(position);
    }


    /*
     * <ExpressionStmt> ::= <Expression> ;
     */
    private ExprStmt parseExpressionStmt() {
        int position = currentToken.position;
        Expr expr = parseExpression();
        checkTokenAndAdvance(position, SEMICOLON, ";");
        return new ExprStmt(position, expr);
    }


    /*
     * <DeclStmt> ::= VAR <Identifier> = <Expression> ;
     * every local variable must be initialized
     */
    private Stmt parseDeclStmt() {
        int position = currentToken.position;
        advance();

        String name = parseIdentifier();
        checkTokenAndAdvance(position, ASSIGN, "=");

        Expr initExpr = parseExpression();

        checkTokenAndAdvance(position, SEMICOLON, ";");
        return new DeclStmt(position, name, initExpr);
    }


    /*
     * <ForStmt> ::= FOR ( <Start> ; <Terminate> ; <Increment> ) <STMT>
     * <Start>     ::= EMPTY | <Expression>
     * <Terminate> ::= EMPTY | <Expression>
     * <Increment> ::= EMPTY | <Expression>
     */
    private Stmt parseFor() {
        int position = currentToken.position;
        advance();

        checkTokenAndAdvance(position, LPAREN, "(");

        Expr start = null;
        if (currentToken.kind != SEMICOLON) {
            start = parseExpression();
        }
        checkTokenAndAdvance(position, SEMICOLON, ";");

        Expr terminate = null;
        if (currentToken.kind != SEMICOLON) {
            terminate = parseExpression();
        }
        checkTokenAndAdvance(position, SEMICOLON, ";");

        Expr increment = null;
        if (currentToken.kind != RPAREN) {
            increment = parseExpression();
        }
        checkTokenAndAdvance(position, RPAREN, ")");

        Stmt stmt = parseStatement();
        return new ForStmt(position, start, terminate, increment, stmt);
    }


    /*
     * <BlockStmt> ::= { <Body> }
     * <Body> ::= EMPTY | <Stmt> <Body>
     */
    private Stmt parseBlock() {
        int position = currentToken.position;
        checkTokenAndAdvance(position, LCURLY, "{");

        StmtList stmtList = new StmtList(position);

        while (currentToken.kind != RCURLY) {
            Stmt aStmt = parseStatement();
            stmtList.addElement(aStmt);
        }
        advance();
        return new BlockStmt(position, stmtList);
    }


    /*
     * <IfStmt> ::= IF ( <Expr> ) <Stmt> | IF ( <Expr> ) <Stmt> ELSE <Stmt>
     */
    private Stmt parseIf() {
        int position = currentToken.position;
        advance();

        checkTokenAndAdvance(position, LPAREN, "(");

        Expr predExpr = parseExpression();
        checkTokenAndAdvance(position, RPAREN, ")");
        Stmt thenStmt = parseStatement();

        Stmt elseStmt = null;
        if (currentToken.kind == ELSE) {
            advance();
            elseStmt = parseStatement();
        }
        return new IfStmt(position, predExpr, thenStmt, elseStmt);
    }


    //-----------------------------------------
    // Expressions
    // Here we introduce the precedence to operations

    /*
     * <Expression> ::= <LogicalOrExpr> <OptionalAssignment>
     * <OptionalAssignment> ::= EMPTY | = <Expression>
     */
    private Expr parseExpression() {
        int position = currentToken.position;

        Expr left = parseOrExpr();
        if (currentToken.kind == ASSIGN) {
            advance();
            Expr right = parseExpression();

            // assign variable
            String leftRef = null;
            if (left instanceof VarExpr) {
                VarExpr leftVar = (VarExpr) left;
                if (leftVar.getRef() != null) {
                    if (!(leftVar.getRef() instanceof VarExpr)) {
                        registerError("<identifier> expected", position);
                    }
                    leftRef = ((VarExpr) leftVar.getRef()).getName();
                }
                left = new AssignExpr(position, leftRef, leftVar.getName(), right);
            }

            // assign member of an array
            else if (left instanceof ArrayExpr) {
                ArrayExpr leftVar = (ArrayExpr) left;
                if (leftVar.getRef() != null) {
                    if (!(leftVar.getRef() instanceof VarExpr)) {
                        registerError("<identifier> expected", position);
                    }
                    leftRef = ((VarExpr) leftVar.getRef()).getName();
                }
                left = new ArrayAssignExpr(position, leftRef, leftVar.getName(),
                        leftVar.getIndex(), right);
            }

            else {
                registerError("<VarExpr> expected", position);
            }
        }
        return left;
    }


    /*
     * <LogicalOR> ::= <logicalAND> <LogicalORRest>
     * <LogicalORRest> ::= EMPTY |  || <LogicalAND> <LogicalORRest>
     */
    private Expr parseOrExpr() {
        int position = currentToken.position;

        Expr left = parseAndExpr();
        while (currentToken.spelling.equals("||")) {
            advance();
            Expr right = parseAndExpr();
            left = new BinaryLogicOrExpr(position, left, right);
        }
        return left;
    }


    /*
     * <LogicalAND> ::= <ComparisonExpr> <LogicalANDRest>
     * <LogicalANDRest> ::= EMPTY |  && <ComparisonExpr> <LogicalANDRest>
     */
    private Expr parseAndExpr() {
        int position = currentToken.position;

        Expr left = parseEqualityExpr();
        while (currentToken.spelling.equals("&&")) {
            advance();
            Expr right = parseEqualityExpr();
            left = new BinaryLogicAndExpr(position, left, right);
        }
        return left;
    }


    /*
     * <ComparisonExpr> ::= <RelationalExpr> <equalOrNotEqual> <RelationalExpr> |
     *                     <RelationalExpr>
     * <equalOrNotEqual> ::=  == | !=
     */
    private Expr parseEqualityExpr() {
        int position = currentToken.position;

        Expr left = parseRelationalExpr();

        if (currentToken.spelling.equals("==")) {
            advance();
            Expr right = parseRelationalExpr();
            left = new BinaryCompEqExpr(position, left, right);
        } else if (currentToken.spelling.equals("!=")) {
            advance();
            Expr right = parseRelationalExpr();
            left = new BinaryCompNeExpr(position, left, right);
        }
        return left;
    }


    /*
     * <RelationalExpr> ::=<AddExpr> | <AddExpr> <ComparisonOp> <AddExpr>
     * <ComparisonOp> ::=  < | > | <= | >= | INSTANCEOF
     */
    private Expr parseRelationalExpr() {
        int position = currentToken.position;

        Expr left = parseAddExpr();
        if (currentToken.kind == COMPARE &&
                (currentToken.spelling.contains("<") || currentToken.spelling.contains(">"))
                || currentToken.kind == INSTANCEOF) {
            String op = parseOperator();
            Expr right = parseAddExpr();
            switch (op) {
                case "<":
                    left = new BinaryCompLtExpr(position, left, right);
                    break;
                case ">":
                    left = new BinaryCompGtExpr(position, left, right);
                    break;
                case "<=":
                    left = new BinaryCompLeqExpr(position, left, right);
                    break;
                case ">=":
                    left = new BinaryCompGeqExpr(position, left, right);
                    break;
                default:
                    if (right instanceof VarExpr) {
                        left = new InstanceofExpr(position, left, ((VarExpr) right).getName());
                    }
                    else if (right instanceof ArrayExpr) {
                        left = new InstanceofExpr(position, left,
                                ((ArrayExpr) right).getName() + "[]");
                    }
                    else {
                        registerError("<identifier> expected", position);
                    }
            }
        }
        return left;
    }


    /*
     * <AddExpr>::= <MultExpr> <MoreMultExpr>
     * <MoreMultExpr> ::= EMPTY | + <MultExpr> <MoreMultExpr> | - <MultExpr> <MoreMultExpr>
     */
    private Expr parseAddExpr() {
        int position = currentToken.position;

        Expr left = parseMultExpr();

        while (currentToken.kind == PLUSMINUS) {
            String op = parseOperator();
            Expr right = parseMultExpr();
            switch (op) {
                case "+":
                    left = new BinaryArithPlusExpr(position, left, right);
                    break;
                case "-":
                    left = new BinaryArithMinusExpr(position, left, right);
                    break;
            }
        }
        return left;
    }


    /*
     * <MultiExpr> ::= <NewCastOrUnary> <MoreNCU>
     * <MoreNCU> ::= * <NewCastOrUnary> <MoreNCU> |
     *               / <NewCastOrUnary> <MoreNCU> |
     *               % <NewCastOrUnary> <MoreNCU> |
     *               EMPTY
     */
    private Expr parseMultExpr() {
        int position = currentToken.position;

        Expr left = parseNewCastOrUnary();

        while (currentToken.kind == MULDIV) {
            String op = parseOperator();
            Expr right = parseNewCastOrUnary();
            switch (op) {
                case "*":
                    left = new BinaryArithTimesExpr(position, left, right);
                    break;
                case "/":
                    left = new BinaryArithDivideExpr(position, left, right);
                    break;
                case "%":
                    left = new BinaryArithModulusExpr(position, left, right);
                    break;
            }
        }
        return left;
    }


    /*
     * <NewCastOrUnary> ::= < NewExpression> | <CastExpression> | <UnaryPrefix>
     */
    private Expr parseNewCastOrUnary() {
        Expr expr;

        switch (currentToken.kind) {
            case NEW:
                expr = parseNew();
                break;
            case CAST:
                expr = parseCast();
                break;
            default:
                expr = parseUnaryPrefix();
                break;
        }
        return expr;
    }


    /*
     * <NewExpression> ::= NEW <Identifier> ( ) | NEW <Identifier> [ <Expression> ]
     */
    private Expr parseNew() {
        int position = currentToken.position;
        Expr newExpr = null;

        checkTokenAndAdvance(position, NEW, "new");

        String identifier = parseIdentifier();

        if (currentToken.kind == LPAREN) {
            advance();
            checkTokenAndAdvance(position, RPAREN, ")");
            newExpr = new NewExpr(position, identifier);
        } else if (currentToken.kind == LBRACKET) {
            advance();
            Expr size = parseExpression();
            checkTokenAndAdvance(position, RBRACKET, "]");
            newExpr = new NewArrayExpr(position, identifier, size);
        } else {
            registerError("'(' or '[' expected", position);
            advance();
        }

        return newExpr;
    }


    /*
     * <CastExpression> ::= CAST ( <Type> , <Expression> )
     */
    private Expr parseCast() {
        int position = currentToken.position;

        checkTokenAndAdvance(position, CAST, "cast");
        checkTokenAndAdvance(position, LPAREN, "(");

        String type = parseType();

        checkTokenAndAdvance(position, COMMA, ",");

        Expr expr = parseExpression();

        checkTokenAndAdvance(position, RPAREN, ")");
        return new CastExpr(position, type, expr);
    }


    /*
     * <UnaryPrefix> ::= <PrefixOp> <UnaryPrefix> | <UnaryPostfix>
     * <PrefixOp> ::= - | ! | ++ | --
     */
    private Expr parseUnaryPrefix() {
        int position = currentToken.position;

        if (!currentToken.spelling.equals("-") &&
                !currentToken.spelling.equals("!") &&
                !currentToken.spelling.equals("++") &&
                !currentToken.spelling.equals("--")) {
            return parseUnaryPostfix();
        }

        String op = parseOperator();
        switch (op) {
            case "-":
                return new UnaryNegExpr(position, parseUnaryPrefix());
            case "!":
                return new UnaryNotExpr(position, parseUnaryPrefix());
            case "++":
                return new UnaryIncrExpr(position, parseUnaryPrefix(), false);
            default:
                return new UnaryDecrExpr(position, parseUnaryPrefix(), false);
        }
    }


    /*
     * <UnaryPostfix> ::= <Primary> <PostfixOp>
     * <PostfixOp> ::= ++ | -- | EMPTY
     */
    private Expr parseUnaryPostfix() {
        int position = currentToken.position;

        Expr expr = parsePrimary();
        if (currentToken.kind == UNARYINCR || currentToken.kind == UNARYDECR) {
            String op = parseOperator();
            if (op.equals("++")) {
                return new UnaryIncrExpr(position, expr, true);
            }
            if (op.equals("--")) {
                return new UnaryDecrExpr(position, expr, true);
            }
        }
        return expr;
    }


    /* <Primary> ::=  <IntegerConst>
     *              | <BooleanConst>
     *              | <StringConst> <Suffix>
     *              | <Identifier> <Suffix>
     *              | ( <Expression> ) <Suffix>
     * <Suffix> ::=   . <Identifier> <Suffix>
     *              | [ <Expression> ] <Suffix>
     *              | ( <Arguments> ) <Suffix>
     *              | EMPTY
     */
    private Expr parsePrimary() {
        int position = currentToken.position;

        Expr expr;
        // parse constants without suffixes
        if (currentToken.kind == INTCONST) {
            expr = parseIntConst();
        }
        else if (currentToken.kind == BOOLEAN) {
            expr = parseBoolean();
        }
        else {
            // there is possibly a suffix
            if (currentToken.kind == STRCONST) {
                expr = parseStringConst();
            }
            else if (currentToken.kind == LPAREN) {
                advance();
                expr = parseExpression();
                checkTokenAndAdvance(position, RPAREN, ")");
            }
            else {
                String name = parseIdentifier();
                expr = new VarExpr(position, null, name);
            }
            // parse suffixes
            while (currentToken.kind == DOT || currentToken.kind == LBRACKET
                    || currentToken.kind == LPAREN) {
                if (currentToken.kind == DOT) {
                    advance();
                    String name = parseIdentifier();
                    expr = new VarExpr(position, expr, name);
                }
                else if (currentToken.kind == LBRACKET) {
                    advance();
                    Expr index = new VarExpr(position, null, null);
                    if (currentToken.kind != RBRACKET) {
                        index = parseExpression();
                    }
                    checkTokenAndAdvance(position, RBRACKET, "]");

                    if (expr instanceof VarExpr) {
                        VarExpr prefix = (VarExpr) expr;
                        expr = new ArrayExpr(position, prefix.getRef(),
                                prefix.getName(), index);
                    }
                    else {
                        expr = new ArrayExpr(position, expr, null, index);
                    }
                }
                else {
                    advance();
                    ExprList exprList = new ExprList(position);
                    if (currentToken.kind != RPAREN) {
                        exprList = parseArguments();
                    }
                    checkTokenAndAdvance(position, RPAREN, ")");
                    if (expr instanceof VarExpr) {
                        VarExpr prefix = (VarExpr) expr;
                        expr = new DispatchExpr(position, prefix.getRef(),
                                prefix.getName(), exprList);
                    } else {
                        expr = new DispatchExpr(position, expr, null, exprList);
                    }
                }
            }
        }
        return expr;
    }


    /*
     * <Arguments> ::= EMPTY | <Expression> <MoreArgs>
     * <MoreArgs>  ::= EMPTY | , <Expression> <MoreArgs>
     */
    private ExprList parseArguments() {
        int position = currentToken.position;
        ExprList exprList = new ExprList(position);

        // if argument list is not empty, get first expression
        if (currentToken.kind != RPAREN) {
            Expr expr = parseExpression();
            exprList.addElement(expr);
        }

        // get successive expressions
        while (currentToken.kind == COMMA) {
            advance();
            Expr expr = parseExpression();
            exprList.addElement(expr);
        }
        return exprList;
    }


    /*
     * <Parameters>  ::= EMPTY | <Formal> <MoreFormals>
     * <MoreFormals> ::= EMPTY | , <Formal> <MoreFormals
     */
    private FormalList parseParameters() {
        int position = currentToken.position;

        FormalList formalList = new FormalList(position);

        // if parameter list is not empty, get first expression
        if (currentToken.kind != RPAREN) {
            Formal formal = parseFormal();
            formalList.addElement(formal);
        }

        // get successive expressions
        while (currentToken.kind == COMMA) {
            advance();
            Formal formal = parseFormal();
            formalList.addElement(formal);
        }
        return formalList;
    }


    /*
     * <Formal> ::= <Type> <Identifier>
     */
    private Formal parseFormal() {
        int position = currentToken.position;

        String type = parseType();
        String identifier = parseIdentifier();

        return new Formal(position, type, identifier);
    }


    /*
     * <Type> ::= <Identifier> <Brackets>
     * <Brackets> ::= EMPTY | [ ]
     */
    private String parseType() {
        int position = currentToken.position;

        String identifier = parseIdentifier();
        if (currentToken.kind == LBRACKET) {
            advance();
            checkTokenAndAdvance(position, RBRACKET, "]");
            identifier += "[]";
        }
        return identifier;
    }


    //----------------------------------------
    //Terminals

    private String parseOperator() {
        String spelling = currentToken.spelling;
        advance();
        return spelling;
    }


    private String parseIdentifier() {
        int position = currentToken.position;
        if (currentToken.kind != IDENTIFIER && currentToken.kind != VAR) {
            registerError("<identifier> expected", position);
        }
        String spelling = currentToken.spelling;
        advance();
        return spelling;
    }


    private ConstStringExpr parseStringConst() {
        int position = currentToken.position;
        String spelling = currentToken.spelling;
        advance();
        return new ConstStringExpr(position, spelling);
    }


    private ConstIntExpr parseIntConst() {
        int position = currentToken.position;
        String spelling = currentToken.spelling;
        advance();
        return new ConstIntExpr(position, spelling);
    }


    private ConstBooleanExpr parseBoolean() {
        int position = currentToken.position;
        String spelling = currentToken.spelling;
        advance();
        return new ConstBooleanExpr(position, spelling);
    }

    /**
     * Throw a CompilationException with the given error message and position
     *
     * @param errorMessage String describing the error
     * @param position     the line number where the error occurs
     * @throws CompilationException if reaches EOF
     */
    private void registerError(String errorMessage, int position)
            throws CompilationException {
        errorHandler.register(Error.Kind.PARSE_ERROR, fileName,
                position, errorMessage);
        throw new CompilationException(errorMessage);
    }


    /**
     * Go to the next significant token
     * Throw error if reach EOF
     */
    private void advance() {
        currentToken = scanner.scan();

        // cycle through comments
        while (currentToken.kind == COMMENT) {
            currentToken = scanner.scan();
        }

        // if EOF, throw error
        if (currentToken.kind == EOF) {
            registerError("Reached end of file while parsing",
                    currentToken.position);
        }
    }

    /**
     * Checks if the current token is of the given kind
     * If it is not, registers an error
     * Advances regardless
     */
    private void checkTokenAndAdvance(int position, Token.Kind kind, String expected) {
        if (currentToken.kind != kind) {
            registerError("'" + expected + "' expected", position);
        }
        advance();
    }


    /**
     * Main method scans and parses the given files and prints out
     * if scanning and parsing were successful, or the errors encountered if not
     *
     * @param args a list of file names
     */
    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("Please enter files to scan");
        }

        ErrorHandler errorHandler = new ErrorHandler();
        Parser parser = new Parser(errorHandler);

        for (int i = 0; i < args.length; i++) {
            System.out.println(args[i]);
            try {
                parser.parse(args[i]);
                System.out.println("Scanning and parsing successful");
            } catch (CompilationException e) {
                for (Error error : errorHandler.getErrorList()) {
                    System.out.println(error.toString());
                }
                if (errorHandler.getErrorList().size() == 0) {
                    System.out.println(e.getMessage());
                }
            }
        }
    }
}
